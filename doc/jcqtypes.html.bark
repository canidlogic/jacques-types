`%xml en;
`
` Language versions:
`
`   en - English (US)
`
` You must compile this Bark document with bark before you can view it
` as a valid HTML document.
`
` This Bark document and the HTML document it compiles to are under the
` license described in section C "Specification license" of this
` document.
`
`^{
<!DOCTYPE html>
<!-- Auto-generated by Bark -->
`en=<html lang="en">
  <head>
    <meta charset="utf-8"/>
`^}
`en=`#=    <title>Jacques-Types specification</title>
`^{
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link href="SourceFonts.css" rel="stylesheet"/>
    <style>

body {
  max-width: 35em;
  padding-left: 0.25em;
  padding-right: 0.25em;
  margin-left: auto;
  margin-right: auto;
  margin-bottom: 3.5em;
  font-family: 'Source Serif', serif;
  background-color: WhiteSmoke;
  color: black;
}

:link {
  text-decoration: none;
  color: blue
}

:visited {
  text-decoration: none;
  color: blue
}

.tt {
  font-family: 'Source Code Pro', monospace;
  background-color: LightGray;
}

hr {
  margin-top: 2.5em;
}

#toc {
  background-color: white;
  padding: 0.5em;
  border: thin solid;
  margin-bottom: 1.5em;
  font-family: 'Source Sans 3', sans-serif;
}

#tochead {
  text-align: center;
  font-weight: bold;
  margin-bottom: 1em;
}

#toc ul {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 1.5em;
  padding-right: 1.5em;
}

h1 {
  font-family: 'Source Sans 3', sans-serif;
  margin-bottom: 0;
  text-align: center;
}

#verline {
  font-family: 'Source Sans 3', sans-serif;
  font-size: 150%;
  text-align: center;
}

h2 {
  font-family: 'Source Sans 3', sans-serif;
}

h3 {
  font-family: 'Source Sans 3', sans-serif;
}

h4 {
  font-family: 'Source Sans 3', sans-serif;
}

li {
  font-family: 'Source Sans 3', sans-serif;
}

#footline {
  font-size: smaller;
  text-align: right;
}

.iblock {
  font-family: 'Source Sans 3', sans-serif;
}

.cblock {
  background-color: white;
  color: indigo;
  padding: 0.5em;
  font-family: 'Source Code Pro', monospace;
  border: thin dotted;
  overflow: auto;
}

.chead {
  text-decoration: underline;
  margin-top: 1em;
  margin-bottom: 1em;
}

.chead:first-child {
  margin-top: 0;
}

.ci {
  margin-left: 2em;
  margin-top: 1em;
}

#titlebox {
  background-color: white;
  margin-top: 3em;
  margin-bottom: 3em;
  padding-top: 0.5em;
  padding-bottom: 1.5em;
  border: medium double;
}

#tusafe table {
  border-collapse: collapse;
}

#tusafe th {
  border: thin solid;
  padding-left: 0.5em;
  padding-right: 0.5em;
  text-align: center;
  font-family: 'Source Sans 3', sans-serif;
}

#tusafe td {
  border: thin solid;
  padding-left: 0.5em;
  padding-right: 0.5em;
  text-align: center;
  font-family: 'Source Code Pro', monospace;
}

#tusafe .desc {
  text-align: left;
  font-family: 'Source Sans 3', sans-serif;
}

#teschar table {
  border-collapse: collapse;
}

#teschar th {
  border: thin solid;
  padding-left: 0.5em;
  padding-right: 0.5em;
  text-align: center;
  font-family: 'Source Sans 3', sans-serif;
}

#teschar td {
  border: thin solid;
  padding-left: 0.5em;
  padding-right: 0.5em;
  text-align: center;
  font-family: 'Source Code Pro', monospace;
}

#teschar .desc {
  text-align: left;
  font-family: 'Source Sans 3', sans-serif;
}

#pport table {
  border-collapse: collapse;
}

#pport th {
  border: thin solid;
  padding-left: 0.5em;
  padding-right: 0.5em;
  text-align: center;
  font-family: 'Source Sans 3', sans-serif;
}

#pport td {
  border: thin solid;
  padding-left: 0.5em;
  padding-right: 0.5em;
  text-align: left;
  font-family: 'Source Code Pro', monospace;
}

#pport .num {
  text-align: right;
  font-family: 'Source Sans 3', sans-serif;
}

#xesc table {
  border-collapse: collapse;
}

#xesc th {
  border: thin solid;
  padding-left: 0.5em;
  padding-right: 0.5em;
  text-align: center;
  font-family: 'Source Sans 3', sans-serif;
}

#xesc td {
  border: thin solid;
  padding-left: 0.5em;
  padding-right: 0.5em;
  text-align: center;
  font-family: 'Source Code Pro', monospace;
}

#xesc .esc {
  text-align: left;
}

    </style>
  </head>
  <body>
`^}

<div id="titlebox">
`en=<h1>Jacques-Types specification</h1>
`en=<div id="verline">Version 1.0</div>
</div>

<div id="toc">
`en=<div id="tochead">Table of Contents</div>
<ul>
`en=  <li>1. <a href="#sec1">Introduction</a></li>
`en=  <li>2. <a href="#sec2">Common definitions</a>
    <ul>
`en=      <li>2.1 <a href="#sec2p1">Path text definition</a></li>
`en=      <li>2.2 <a href="#sec2p2">Resource path definition</a></li>
`en=      <li>2.3 <a href="#sec2p3">Domain definition</a></li>
`en=      <li>2.4 <a href="#sec2p4">Server class</a></li>
`en=      <li>2.5 <a href="#sec2p5">URL class</a></li>
`en=      <li>2.6 <a href="#sec2p6">URL definition</a></li>
`en=      <li>2.7 <a href="#sec2p7">Email definition</a></li>
`en=      <li>2.8 <a href="#sec2p8">Timestamp definition</a></li>
`en=      <li>2.9 <a href="#sec2p9">Atom definition</a></li>
`en=      <li>2.10 <a href="#sec2p10">Unicode string definition</a></li>
`en=      <li>2.11 <a href="#sec2p11">Filename definition</a></li>
    </ul>
  </li>
</ul>
<div>;_</div>
<ul>
`en=  <li>A. <a href="#secA">External references</a></li>
`en=  <li>B. <a href="#secB">Building the specification</a></li>
`en=  <li>C. <a href="#secC">Specification license</a></li>
</ul>
</div>

`en=<h2 id="sec1">1. Introduction</h2>

`en=<p>Jacques-;//Types is a collection of PHP utility functions for normalizing and checking common data types such as paths, URLs, emails, and timestamps.</p>

`en=<p>The whole module is contained within <span class="tt">jcqtypes;//.php</span> which has no further dependencies.  This specification defines the common types in detail.</p>

`en=<p>Most utility functions for normalizing and validating the data types are provided as static functions on the <span class="tt">JCQ;//Types</span> class, though some types have their own classes, as documented later in this specification.</p>

`en=<h2 id="sec2">2. Common definitions</h2>

`en=<p>The following subsections document various data types that are supported by Jacques-Types.  Some of the subsections refer to a <span class="tt">blank;//Check()</span> function.  This function is used when normalizing components of complex strings, to make sure that internal components are not allowed to have whitespace padding.</p>

`en=<p>The function is defined like this:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>blankCheck</b>(<br/>
  $str : string | mixed<br/>
) : boolean
`$
</blockquote>

`en=<p>If the given parameter is not a string, <span class="tt">false</span> is returned.  If the given parameter is an empty string, <span class="tt">false</span> is also returned.  If the given parameter is a non-;//empty string that begins or ends with a whitespace character, then <span class="tt">false</span> is returned.  If the given parameter is a non-;//empty string that neither begins nor ends with a whitespace character, then <span class="tt">true</span> is returned.</p>

`en=<p>Whitespace for this function is defined by the default whitespace characters used by the PHP <span class="tt">trim()</span> function, which are Space (SP), Horizontal Tab (HT), Carriage Return (CR), Line Feed (LF), Nul (NUL), and Vertical Tab (VT).</p>

`en=<h3 id="sec2p1">2.1 Path text definition</h3>

`en=<p><i>Path text</i> represents encoded text used within a <a href="#sec2p2">resource path</a> (;&S2.2) or within the query or fragment portions of <a href="#sec2p6">URLs</a> (;&S2.6).</p>

`en=<p>The definition given in this section is based on the <span class="tt">pchar</span> definition in <a href="#extRFC3986">[RFC-;//3986]</a>.  However, the RFC gives a slightly different definition for path text used within query or fragment portions, allowing in those cases for the <span class="tt">/</span> and <span class="tt">?</span> characters to be used without encoding.  The definition given in this section still requires these characters to be encoded in query and fragment portions, and the RFC mentions in ;&S3.4 that some ;'(older, erroneous implementations;') may not handle things correctly when those two characters are unencoded in the query portion.  Always encoding them is still valid according to the RFC.</p>

`en=<p>Path text is a string of zero or more characters.  To normalize path text, the first step is to trim leading and trailing whitespace.  However, do <i>not</i> convert uppercase letters to lowercase, since path text may be case sensitive.</p>

`en=<p>After trimming, look through the path text for <span class="tt">%</span> characters that are followed by two base-16 digits.  The two base-16 digits are decoded into a numeric character value.  A decision must then be made whether the decoded numeric value really has to be percent-;//encoded or not.  The following rules determine what has to be percent-;//encoded:</p>

<blockquote class="iblock">
`en=<p>(1) If the numeric value is less than <span class="tt">0x21</span> then the value must always be percent-;//encoded.</p>

`en=<p>(2) If the numeric value is greater than <span class="tt">0x7E</span> then the value must always be percent-;//encoded.</p>

`en=<p>(3) If the numeric value corresponds to one of the ;'(unsafe;') characters shown in the table below, then the value must always be percent-;//encoded.</p>

`en=<p>(4) In all other cases, the numeric value does <i>not</i> need to be percent-;//encoded.</p>
</blockquote>

`en=<p>The following table presents the ;'(unsafe;') characters:</p>

<blockquote id="tusafe">
<table>
  <tr>
    <th>Char</th>
    <th>Code</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>"</td>
    <td>0x22</td>
    <td class="desc">Double quote</td>
  </tr>
  <tr>
    <td>#</td>
    <td>0x23</td>
    <td class="desc">Number sign</td>
  </tr>
  <tr>
    <td>%</td>
    <td>0x25</td>
    <td class="desc">Percent sign</td>
  </tr>
  <tr>
    <td>/</td>
    <td>0x2F</td>
    <td class="desc">Forward slash</td>
  </tr>
  <tr>
    <td>{[</td>
    <td>0x3C</td>
    <td class="desc">Less-than sign</td>
  </tr>
  <tr>
    <td>{]</td>
    <td>0x3E</td>
    <td class="desc">Greater-than sign</td>
  </tr>
  <tr>
    <td>?</td>
    <td>0x3F</td>
    <td class="desc">Question mark</td>
  </tr>
  <tr>
    <td>[</td>
    <td>0x5B</td>
    <td class="desc">Left square bracket</td>
  </tr>
  <tr>
    <td>\</td>
    <td>0x5C</td>
    <td class="desc">Backslash</td>
  </tr>
  <tr>
    <td>]</td>
    <td>0x5D</td>
    <td class="desc">Right square bracket</td>
  </tr>
  <tr>
    <td>^</td>
    <td>0x5E</td>
    <td class="desc">Circumflex</td>
  </tr>
  <tr>
    <td>`</td>
    <td>0x60</td>
    <td class="desc">Grave accent</td>
  </tr>
  <tr>
    <td>{(</td>
    <td>0x7B</td>
    <td class="desc">Left curly bracket</td>
  </tr>
  <tr>
    <td>|</td>
    <td>0x7C</td>
    <td class="desc">Vertical bar</td>
  </tr>
  <tr>
    <td>{)</td>
    <td>0x7D</td>
    <td class="desc">Right curly bracket</td>
  </tr>
</table>
</blockquote>

`en=<p>If the process given above determines that the numeric code <i>does</i> need to be escaped, then the original percent escape is replaced with an equivalent percent escape that uses uppercase base-16 digits.</p>

`en=<p>If the process given above determines that the numeric code does <i>not</i> need to be escaped, then the original percent escape is replaced by the literal character it was escaping.</p>

`en=<p>The final normalization step is to look for the characters <span class="tt">/</span> and <span class="tt">?</span> within the path text and replace them with percent escapes.  This applies to query text and fragment text that is using the more liberal syntax allowed by RFC-3986, as described earlier in this section.</p>

`en=<p>The normalization procedure does not do any special processing with encoded characters beyond ASCII range.  In particular, if these extended characters represent UTF-8 encodings of Unicode characters, the normalization procedure does <i>not</i> check that the UTF-8 is valid, nor does it attempt any kind of Unicode normalization.</p>

`en=<p>To normalize path text according to the procedure described above, use the following function:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>normPathText</b>(<br/>
  $str : string | mixed<br/>
) : string
`$
</blockquote>

`en=<p>This function takes a string parameter to normalize.  If a non-string is passed, then the function will act as though the parameter were an empty string.  The return value is the normalized path text.  The return value is <i>not</i> guaranteed to be valid.  You must validate the normalized path text using the function described later in this section to check that path text really is valid.</p>

`en=<p>To validate a normalized path text string, the following procedure is used for each character (empty strings are valid path text, too):</p>

<blockquote class="iblock">
`en=<p>(1) If the character is <span class="tt">%</span> then it must be followed by two uppercase base-16 digits.  The decoded value of these base-16 digits must either be: (1) less than <span class="tt">0x21</span>;; (2) greater than <span class="tt">0x7E</span>;; or (3) one of the ;'(unsafe;') characters defined in the table earlier in this section.</p>

`en=<p>(2) No character code in the path text may have a numeric value less than <span class="tt">0x21</span>.</p>

`en=<p>(3) No character code in the path text may have a numeric value greater than <span class="tt">0x7E</span>.</p>

`en=<p>(4) No character in the path text may be one of the ;'(unsafe;') characters defined in the table earlier in this section <b>except</b> that <span class="tt">%</span> is allowed (provided that it also follows rule (1) given above).</p>
</blockquote>

`en=<p>The following function performs the validation checks described above on a normalized path text string:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>checkPathText</b>(<br/>
  $str : string | mixed<br/>
) : boolean
`$
</blockquote>

`en=<p>If a non-string parameter is passed, the return value is always <span class="tt">false</span>.  Path text strings should be normalized first with <span class="tt">norm;//Path;//Text()</span> before passing them to the validation function, or validation may fail.  The return value is <span class="tt">true</span> if the path text is valid, <span class="tt">false</span> if the path text is not valid.  Empty strings are valid, but NULL is not valid.</p>

`en=<h3 id="sec2p2">2.2 Resource path definition</h3>

`en=<p>A <i>resource path</i> represents the absolute path to a public resource on a server, <i>not</i> including any query or fragment.  Although it has a similar syntax, it is completely different from a file path.  Resource paths are used as part of HTTP requests.  The definition given in this section is based on the <span class="tt">path-;//absolute</span> definition in <a href="#extRFC3986">[RFC-;//3986]</a> except it is a bit stricter to filter out some unusual cases.</p>

`en=<p>Before being validated, a resource path must be normalized.  To prevent misuse of resource paths, normalization begins with a check whether any <span class="tt">?</span> or <span class="tt">#</span> characters are present within the resource path.  If any such characters are detected, the normalization procedure returns an empty string to prevent such resource paths from validating.</p>

`en=<p>The normalization process begins by trimming leading and trailing whitespace from the resource path.  The resource path is <i>not</i> converted to lowercase, since resource paths might be case-;//sensitive.</p>

`en=<p>The next normalization step is to accumulate path components.  The path component buffer starts out empty and characters are added to it until either a <span class="tt">/</span> character is encountered or the end of the path is encountered.  When one of these two conditions occur, then if the path component buffer is not empty, it is normalized and the original path component is replaced with the normalized version.  (If the path component buffer is empty, nothing is done.)  The path component buffer is then reset to empty.  The <span class="tt">/</span> characters are never included within path component buffers.</p>

`en=<p>To normalize a path component buffer, first pass it through the <span class="tt">blank;//Check()</span> function <a href="#sec2">defined earlier</a> (;&S2).  If the result of this is <span class="tt">false</span>, do not normalize this (invalid) path component and leave it as-is in the path string.  If the result is <span class="tt">true</span>, then pass the path component through the <span class="tt">norm;//Path;//Text()</span> function described in ;&S2.1 <a href="#sec2p1">Path text definition</a> to normalize the component before putting it back into the path string.</p>

`en=<p>The resource path normalization procedure described above is performed with the following function:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>normResPath</b>(<br/>
  $str : string | mixed<br/>
) : string
`$
</blockquote>

`en=<p>Passing a non-string parameter has the same effect as passing an empty string.  The return value is <i>not</i> guaranteed to be valid.  You must pass the normalized result through the validation process below to ensure that it is valid.</p>

`en=<p>To validate a resource path, first check that it is at least one character and that the first character is the <span class="tt">/</span> symbol.</p>

`en=<p>Second, check that no <span class="tt">/</span> character occurs immediately after another <span class="tt">/</span> character.  Although this is sometimes allowed according to RFC-3986, the validation procedure here does not allow it since it is unusual.</p>

`en=<p>Third, if the resource path consists just of <span class="tt">/</span> and nothing else, then return that the resource path is valid without performing any further validation.</p>

`en=<p>Fourth, if we got to this step then there are at least two characters in the resource path, so ignore the leading <span class="tt">/</span> and focus on the rest of the resource path string.  Also, if the last character of the resource path is not <span class="tt">/</span> then append this character to the resource path (just for the purposes of validation).</p>

`en=<p>Fifth, divide the rest of the path string into path components, each terminated by the <span class="tt">/</span> character (which is <i>not</i> included in any component).</p>

`en=<p>Sixth and finally, the resource path is valid if each of the path components received in the previous step passes the <span class="tt">check;//Path;//Text()</span> function defined in ;&S2.1 <a href="#sec2p1">Path text definition</a> <b>AND</b> none of the path components are a match for the relative path components <span class="tt">.</span> or <span class="tt">..</span> which are allowed by the RFC but not by this validation procedure.</p>

`en=<p>The following function performs the validation checks described above on a normalized resource path string:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>checkResPath</b>(<br/>
  $str : string | mixed<br/>
) : boolean
`$
</blockquote>

`en=<p>If a non-string parameter is passed, the return value is always <span class="tt">false</span>.  Resource path strings should be normalized first with <span class="tt">norm;//Res;//Path()</span> before passing them to the validation function, or validation may fail.  The return value is <span class="tt">true</span> if the resource path is valid, <span class="tt">false</span> if the resource path is not valid.</p>

`en=<h3 id="sec2p3">2.3 Domain definition</h3>

`en=<p>A <i>domain</i> identifies a particular server on the internet.  The definition given in this section is based on the ;'(Restrictions on domain (DNS) names;') given in <a href="#extRFC3696">[RFC-;//3696]</a>.  Domains as defined in this section can identify servers that have valid DNS addresses, but they can;''t be used for servers that are idenitified by IP addresses only or some non-DNS naming scheme.</p>

`en=<p>Note that <span class="tt">local;//host</span> is <b>not</b> a valid domain according to the definition in this section because it doesn;''t have a period character.  To use <span class="tt">local;//host</span> within a <a href="#sec2p6">URL</a> (;&S2.6), you should instead use the IP address <span class="tt">127.0.0.1</span>.</p>

`en=<p>Before being checked, a domain must be normalized by the following procedure.  First, leading and trailing whitespace is trimmed.  Second, if the last character is a period, it is dropped.  Third, uppercase ASCII letters in the domain are changed to lowercase ASCII letters.</p>

`en=<p>The following function is available to perform this normalization:</p> 

<blockquote class="cblock">
`#L:
JCQTypes::<b>normDomain</b>(<br/>
  $str : string | mixed<br/>
) : string
`$
</blockquote>

`en=<p>If something besides a string is passed to it, an empty string will be returned, which is not a valid domain.  The function does <i>not</i> verify that domains are valid.</p>

`en=<p>Once a domain has been normalized as described above, it can be validated by using the following procedure.</p>

`en=<p>The first check on a normalized domain is that its length does not exceed 255 characters.  The second check on a normalized domain is that it contains at least one period character.  The third check on a normalized domain is that the last character is not a period.</p>

`en=<p>The domain is then split at the last period character, with everything up to <i>and including</i> the last period being the lower part and everything after the last period being the upper part.  A check is made that the upper part contains at least one character that is not an ASCII decimal digit.  Another check is made that the first character of the lower part is not a period.  Finally, a check is made that within the lower part, no period character is immediately preceded by another period character.</p>

`en=<p>The lower part is then split into a sequence of one or more labels, with each name terminated by a period character which is <i>not</i> part of the label.  The upper part is then added to this list as the last label, such that the domain has been split into a sequence of two or more labels.</p>

`en=<p>Each label must be no more than 63 characters long.  Furthermore, each character must either be a lowercase ASCII letter, an ASCII decimal digit, or an ASCII hyphen.  Finally, neither the first nor the last letter in a label may be a hyphen.</p> 

`en=<p>The function to check whether a normalized domain string is valid is defined below:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>checkDomain</b>(<br/>
  $str : string | mixed<br/>
) : boolean
`$
</blockquote>

`en=<p>Passing a non-string parameter always causes the function to return <span class="tt">false</span>.  The function returns a boolean value that is <span class="tt">true</span> if the domain is valid and <span class="tt">false</span> if the domain is invalid.</p>

`en=<h3 id="sec2p4">2.4 Server class</h3>

`en=<p>The <i>server class</i> refers to the <span class="tt">JCQ;//Server;//Type</span> class.  This helper class is designed for use by the <a href="#sec2p5">URL class</a> (;&S2.5) in parsing URLs.  The server class handles parsing the domain or IP address along with an optional port.</p>

`en=<p>The server class is constructed with the string value to parse:</p>

<blockquote class="cblock">
`#L:
new <b>JCQServerType</b>(<br/>
  $str : string | mixed<br/>
)
`$
</blockquote>

`en=<p>If a non-;//string parameter is passed, the effect is the same as passing an empty string.</p>

`en=<p>The first operation performed by the constructor is to trim the given string of leading and trailing whitespace.</p>

`en=<p>The second operation is to search for a <span class="tt">:</span> character within the string.  If a colon is present, then the first colon and everything after it is removed from the string and saved as the <i>port</i>.  If no colon is present, then an empty string is stored in the port field.</p>

`en=<p>The third operation is to check whether the string is in the form of an IPv4 address.  This is the case if the string contains exactly three period characters and all remaining characters are decimal digits.  Otherwise, the string is a domain.</p>

`en=<p>Finally, the string is stored either as an IPv4 address or as a domain, based on what the previous step determined.</p>

`en=<p>Once the object is constructed, you can query the fields using the following methods:</p>

<blockquote class="cblock">
`#L:
JCQServerType.<b>getDomain</b>(<br/>
) : string<br/>
<br/>
JCQServerType.<b>getIPv4</b>(<br/>
) : string<br/>
<br/>
JCQServerType.<b>getPort</b>(<br/>
) : string<br/>
<br/>
JCQServerType.<b>hasIPv4</b>(<br/>
) : boolean
`$
</blockquote>

`en=<p>The <span class="tt">get</span> functions always return a string, with an empty string returned if the field wasn;''t filled in or it isn;''t relevant.  The <span class="tt">has</span> function determines whether a domain or an IPv4 address is present.  None of the returned strings are guaranteed to be valid.  Also note that object instances are <i>not</i> immutable.</p>

`en=<p>To normalize the values in the fields, use the following function:</p>

<blockquote class="cblock">
`#L=JCQServerType.<b>normalize</b>()
</blockquote>

`en=<p>Even after normalization, the strings returned from the <span class="tt">get</span> functions are not guaranteed to be valid.  You have to validate them separately, as described later in this section.</p>

`en=<p>If a domain is present in the object, first the <span class="tt">blank;//Check()</span> function is used (see ;&S2 <a href="#sec2">Common definitions</a>) to check for whitespace.  If this function fails, it means either that the domain was empty or that there was space between the domain and the colon that begins the port number.  Both cases are not valid, so the domain is normalized to an (invalid) empty string if the <span class="tt">blank;//Check()</span> function fails.  Otherwise, the domain is normalized by passing it through the <span class="tt">norm;//Domain()</span> function defined in ;&S2.3 <a href="#sec2p3">Domain definition</a>.</p>

`en=<p>If an IPv4 address is present in the object, the <span class="tt">blank;//Check()</span> function is used and if it fails, the normalization is set to an (invalid) empty string.  This is to prevent whitespace between the IPv4 address and the port declaration.  Nothing further is done to normalize an IPv4 address.  Note that leading zeroes in the numeric fields could be octal declarations (which are not supported), so leading zeroes are not adjusted by normalization.</p>

`en=<p>If the port string is not empty, then first of all check whether it contains only a colon.  If that is the case, then drop the colon and normalize it to an empty string.  Otherwise, confirm that there are at least two characters, the first character is a colon, and the rest of the characters are decimal digits.  If this is not the case, normalization does not proceed further.  Otherwise, drop any leading zeroes from the port number.</p>

`en=<p>After normalization is performed, you can use the <span class="tt">get</span> functions described earlier to retrieve the normalized field values.  Or, you can use the following function to assemble the normalized fields into a complete string:</p>

<blockquote class="cblock">
`#L:
JCQServerType.<b>getFull</b>(<br/>
) : string
`$
</blockquote>

`en=<p>The function returns the result of concatenating the current value of either the domain or the IPv4 address (depending which is present) with the port string.  If you call this after <span class="tt">normalize()</span> you will get the normalized server address.  The return value of this function is <i>not</i> guaranteed to be valid.  You must perform validation separately, as described below.</p>

`en=<p>To validate the server address, use the following function:</p>

<blockquote class="cblock">
`#L:
JCQServerType.<b>check</b>(<br/>
  $allowip : boolean | mixed<br/>
) : boolean
`$
</blockquote>

`en=<p>If the <span class="tt">allowip</span> parameter is <span class="tt">true</span> then IPv4 addresses will be allowed.  If the parameter is <span class="tt">false</span> then IPv4 addresses are not allowed and validation will fail if an IPv4 address is present.  If the parameter is not boolean, the function will return <span class="tt">false</span>.</p>

`en=<p>Note that during construction, leading and trailing whitespace is trimmed from the original string.  Therefore, for a full validation, you should use the <span class="tt">blank;//Check()</span> function (see ;&S2 <a href="#sec2">Common definitions</a>) before constructing a <span class="tt">JCQ;//Server;//Type</span> object, and fail validation if <span class="tt">blank;//Check()</span> fails.</p>

`en=<p>If a domain is present, then the <span class="tt">check;//Domain()</span> function defined in ;&S2.3 <a href="#sec2p3">Domain definition</a> is used to validate the domain.  Validation of the server object fails if domain validation fails.</p>

`en=<p>If an IPv4 address is present, then for purposes of validation a dot is temporarily added to the end of the IPv4 address.  The IPv4 address is parsed into four fields, each terminated by a dot that is not included in the field.  Nothing may be present in the string after these four fields.  Each field must contain at least one and at most three characters.  All these characters must be decimal digits.  If there is more than one character, then the first character may not be a zero.  Finally, the numeric value of the decimal digits in each field may not exceed 255.</p>

`en=<p>Also, as explained earlier, validation will fail if an IPv4 address is present but the <span class="tt">allowip</span> parameter is not <span class="tt">true</span>.</p>

`en=<p>If the port string is not empty, then it is checked that it is at least two characters, the first character is a colon, the second character is a non-zero decimal digit, and all characters after that are decimal digits.</p>

`en=<p>If all the validation checks above pass, then <span class="tt">true</span> is returned by the validation function;; else, <span class="tt">false</span> is returned.</p>

`en=<p>The server class provides one additional function:</p>

<blockquote class="cblock">
`#L=JCQServerType.<b>clearPort</b>()
</blockquote>

`en=<p>This function clears the port field of the server object to an empty string.  This function is used by the <a href="#sec2p5">URL class</a> (;&S2.5) to remove the port value if it matches the default port for the protocol.  If the server object was already normalized, calling this function will still result in a normalized object.  If the server object was already validated, calling this function will still result in a valid object.</p>

`en=<h3 id="sec2p5">2.5 URL class</h3>

`en=<p>The <i>URL class</i> refers to the <span class="tt">JCQ;//URL;//Type</span> class.  This helper class is designed for use during <a href="#sec2p6">URL normalization and validation</a> (;&S2.6).  It makes use of the <a href="#sec2p4">server class</a> (;&S2.4) for normalization and validation of the server portion of the URL.</p>

`en=<p>The URL class is constructed with the string value to parse:</p>

<blockquote class="cblock">
`#L:
new <b>JCQURLType</b>(<br/>
  $str : string | mixed<br/>
)
`$
</blockquote>

`en=<p>If a non-string parameter is passed, the effect is the same as passing an empty string.</p>

`en=<p>The first operation performed by the constructor is to trim the given string or leading and trailing whitespace.</p>

`en=<p>The second operation is to search for the first <span class="tt">://</span> substring within the given string.  If this substring is not present, the URL is invalid and empty strings are stored within all fields of the object.  Otherwise, the contents of the trimmed string up to <i>and including</i> the <span class="tt">://</span> substring is stored within the protocol field and then dropped from the trimmed input string.</p>

`en=<p>The third operation is to search for the first <span class="tt">/</span> within the strim (which just had the protocol removed).  If this character is not present, the whole string is taken to be server portion and the remaining fields are set to empty.  Otherwise, the server portion is the string up to <i>but excluding</i> the first <span class="tt">/</span> character.  The server portion is then dropped from the input string.</p>

`en=<p>The fourth operation is to apply the <span class="tt">blank;//Check()</span> function defined in ;&S2 <a href="#sec2">Common definitions</a> to the server portion to check for whitespace padding (which is not allowed).  If this check function fails, then set the server portion to blank (which is invalid).  Otherwise, use the server portion to construct an internal <span class="tt">JCQ;//Server;//Type</span> object.</p>

`en=<p>The fifth operation is to search for the first <span class="tt">?</span> character within the remaining input string.  If the <span class="tt">?</span> character is present, then search for the first <span class="tt">#</span> character that occurs after it;; else, search for the first <span class="tt">#</span> character in the whole string.  At the end of this operation, we have the locations of the <span class="tt">?</span> query character, or the <span class="tt">#</span> fragment character, or both, or neither;; furthermore, if both characters occur, the fragment is after the query.</p>

`en=<p>The sixth operation is to extract the fragment, if the fragment character was found in the previous step.  The fragment begins at the fragment character and proceeds to the end of the string.  After being stored, the fragment is removed from the input string.</p>

`en=<p>The seventh operation is to extract the query, if the query character was found.  The query begins at the query character and proceeds to the end of the remaining input string.  After being stored, the query is removed from the input string.</p>

`en=<p>The eighth operation is to store whatever remains of the input in the path field.</p>

`en=<p>Once the object is constructed, you can query the fields using the following methods:</p>

<blockquote class="cblock">
`#L:
JCQURLType.<b>getProtocol</b>(<br/>
) : string<br/>
<br/>
JCQURLType.<b>getServer</b>(<br/>
) : JCQServerType<br/>
<br/>
JCQURLType.<b>getPath</b>(<br/>
) : string<br/>
<br/>
JCQURLType.<b>getQuery</b>(<br/>
) : string<br/>
<br/>
JCQURLType.<b>getFragment</b>(<br/>
) : string
`$
</blockquote>

`en=<p>The <span class="tt">get</span> functions always return a string, with an empty string returned if the field wasn;''t filled in.  However, the <span class="tt">get;//Server()</span> function returns a <span class="tt">JCQ;//Server;//Type</span> object instance (see ;&S2.4 <a href="#sec2p4">Server class</a>).  None of the returned values are guaranteed to be valid.  Also note that instances of this class are <i>not</i> immutable.</p>

`en=<p>To normalize the values in the fields, use the following function:</p>

<blockquote class="cblock">
`#L=JCQURLType.<b>normalize</b>()
</blockquote>

`en=<p>Even after normalization, the values returned from the <span class="tt">get</span> functions are not guaranteed to be valid.  You have to validate them separately, as described later in this section.</p>

`en=<p>The protocol is normalized by converting the string to lowercase.</p>

`en=<p>The server object is normalized in two steps.  First, the <span class="tt">normalize()</span> function is called on the server object.  Second, if the normalized port field matches the default value for the protocol, then the <span class="tt">clear;//Port()</span> function is called on the server object to drop the unnecessary port designation.  The following table shows the default port numbers for each protocol recognized by Jacques-;//Types:</p>

<blockquote id="pport">
<table>
  <tr>
    <th>Protocol</th>
    <th>Default port</th>
  </tr>
  <tr>
    <td>http://</td>
    <td class="num">80</td>
  </tr>
  <tr>
    <td>https://</td>
    <td class="num">443</td>
  </tr>
</table>
</blockquote>

`en=<p>The path is normalized first by checking if it is empty.  If this is the case, then it is set to <span class="tt">/</span> by itself.  Next, apply <span class="tt">blank;//Check()</span> to the path;; if this fails, clear the path to an empty value (which will not validate).  Finally, if the <span class="tt">blank;//Check()</span> function passed, use <span class="tt">norm;//Res;//Path()</span> from ;&S2.2 <a href="#sec2p2">Resource path definition</a> to normalize the path component.</p>

`en=<p>The query and fragment fields are both normalized in the same way.  First of all, if the field is only one character long, clear it to an empty string.  Second, if the field is still not empty, extract everything beyond the first character.  Third, use <span class="tt">blank;//Check()</span> on this remainder string;; if it fails, set the remainder string to <span class="tt">%</span> by itself (which will not validate, even if it is normalized again) and proceed normally.  Fourth, use <span class="tt">norm;//Path;//Text()</span> from ;&S2.1 <a href="#sec2p1">Path text definition</a> to normalize the remainder text.  Finally, combine the normalized remainder text once again with the first character of the field and store this normalized value.</p>

`en=<p>After normalization is performed, you can use the <span class="tt">get</span> functions described earlier to retrieve the normalized field values.  Or, you can use the following function to assemble the normalized fields into a complete string:</p>

<blockquote class="cblock">
`#L:
JCQURLType.<b>getFull</b>(<br/>
) : string
`$
</blockquote>

`en=<p>The function returns the result of concatenating the fields together in the proper order.  If you call this after <span class="tt">normalize()</span> you will get the normalized URL.  The return value of this function is <i>not</i> guaranteed to be valid.  You must perform validation separately, as described below.</p>

`en=<p>To validate the URL, use the following function:</p>

<blockquote class="cblock">
`#L:
JCQURLType.<b>check</b>(<br/>
  $allowip : boolean | mixed<br/>
) : boolean
`$
</blockquote>

`en=<p>If the <span class="tt">allowip</span> parameter is <span class="tt">true</span> then IPv4 addresses will be allowed.  If the parameter is <span class="tt">false</span> then IPv4 addresses are not allowed and validation will fail if an IPv4 address is present.  If the parameter is not boolean, the function will return <span class="tt">false</span>.</p>

`en=<p>Note that during construction, leading and trailing whitespace is trimmed from the original string.  Therefore, for a full validation, you should use the <span class="tt">blank;//Check()</span> function (see ;&S2 <a href="#sec2">Common definitions</a>) before constructing a <span class="tt">JCQ;//Server;//Type</span> object, and fail validation if <span class="tt">blank;//Check()</span> fails.</p>

`en=<p>For the protocol to be valid, it must be either <span class="tt">http://</span> or <span class="tt">https://</span> in lowercase letters.</p>

`en=<p>To validate the server field, a call is made through to the <span class="tt">check()</span> function of the server object, passing through the <span class="tt">allowip</span> parameter.</p>

`en=<p>For the path to be valid, it must pass the <span class="tt">check;//Res;//Path()</span> function defined in ;&S2.2 <a href="#sec2p2">Resource path definition</a>.</p>

`en=<p>For the query to be valid, it must either be empty or it must be at least two characters, the first of which is <span class="tt">?</span>.  All characters after the first must pass <span class="tt">check;//Path;//Text()</span> defined in ;&S2.1 <a href="#sec2p1">Path text definition</a>.</p>

`en=<p>For the fragment to be valid, it must either be empty or it must be at least two characters, the first of which is <span class="tt">#</span>.  All characters after the first must pass <span class="tt">check;//Path;//Text()</span> defined in ;&S2.1 <a href="#sec2p1">Path text definition</a>.</p>

`en=<p>If all the validation checks above pass, then <span class="tt">true</span> is returned by the validation function;; else, <span class="tt">false</span> is returned.</p>

`en=<h3 id="sec2p6">2.6 URL definition</h3>

`en=<p>An <i>URL</i> is a full internet address to a resource, with optional query and fragment parameters.  For the purposes of Jacques-;//Types, only HTTP and HTTPS URLs are supported.  The definition of an URL used in this section is based on the <span class="tt">URI</span> definition given in <a href="#extRFC3986">[RFC-;//3986]</a>, but the definition used in this section is specialized to only HTTP URIs.</p>

`en=<p>Note that URLs with <span class="tt">local;//host</span> as the domain will <b>not</b> validate.  Instead, use the IP address <span class="tt">127.0.0.1</span>.  See the discussion in ;&S2.3 <a href="#sec2p3">Resource path</a> for further information.</p>

`en=<p>The functions in this section are a wrapper around the <a href="#sec2p5">URL class</a> defined in ;&S2.5.</p>

`en=<p>The following function is available to normalize a URL:</p> 

<blockquote class="cblock">
`#L:
JCQTypes::<b>normURL</b>(<br/>
  $str : string | mixed<br/>
) : string
`$
</blockquote>

`en=<p>If something besides a string is passed to it, an empty string will be returned, which is not a valid URL.  The function does <i>not</i> verify that URLs are valid.</p>

`en=<p>This function operates by creating a <span class="tt">JCQ;//URL;//Type</span> object with the given parameter, calling <span class="tt">normalize()</span> on it, and returning the normalized URL with the <span class="tt">get;//Full()</span> function.  See ;&S2.5 <a href="#sec2p5">URL class</a> for further information.</p>

`en=<p>Once an URL has been normalized as described above, it can be validated by using the following function on a normalized URL string:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>checkURL</b>(<br/>
  $str     : string | mixed,<br/>
  $allowip : boolean | mixed<br/>
) : boolean
`$
</blockquote>

`en=<p>If a non-string parameter is passed, the return value is always <span class="tt">false</span>.  URL strings should be normalized first with <span class="tt">norm;//URL()</span> before passing them to the validation function, or validation may fail.  The return value is <span class="tt">true</span> if the URL is valid, <span class="tt">false</span> if the URL is not valid.</p>

`en=<p>The <span class="tt">allowip</span> parameter determine whether IP addresses are allowed instead of a domain.  If it is <span class="tt">true</span> then IP addresses are allowed.  If it is <span class="tt">false</span> then IP addresses are not allowed.  If it is not a boolean value, then the function returns <span class="tt">false</span>.</p>

`en=<p>Allowing IP addresses has the advantage of allowing Jacques-;//Types to work on local servers and on LANs that do not have a DNS system set up.  It is also the only way to work on <span class="tt">local;//host</span> since that is only allowed with an IP address (see earlier in this section).  However, in certain cases (especially when dealing with URLs received from clients), it may be preferable to prevent IP addresses from being used for sake of security.</p>

`en=<p>This function operates by first using the <span class="tt">check;//Blank()</span> function defined in ;&S2 <a href="#sec2">Common definitions</a>.  If this function fails, then <span class="tt">false</span> is returned.  Otherwise, a <span class="tt">JCQ;//URL;//Type</span> object is created on the given parameter, and then the <span class="tt">check()</span> function is used to validate, passing through the given <span class="tt">allowip</span> parameter value.</p>

`en=<h3 id="sec2p7">2.7 Email definition</h3>

`en=<p>An <i>email address</i> is used within Jacques-;//Types to allow users to identify themselves, and also to allow for password reset functionality based on email verification.  The definition given in this section is based on ;'(Restrictions on email addresses;') given in <a href="#extRFC3696">[RFC-;//3696]</a>.  However, the definition in this section is more strict, removing unusual forms such as IP-address email hosts and escape quoting within email names.</p>

`en=<p>Although the standards allow for case sensitivity in the local portion of the email, the definition given in this section has the whole email address as case insensitive and normalized to lowercase.  In practice, case-;//sensitive email addresses are rarely encountered, and allowing them has a chance of duplicate user registrations and possible security issues.</p>

`en=<p>Before being validated, an email address must be normalized.  To normalize an email address, begin by trimming leading and trailing whitespace, and converting the whole address to lowercase letters.</p>

`en=<p>Next, search for the first <span class="tt">@</span> character.  If no such character is present, the whole email address is invalid, so normalize it to an empty string (which is an invalid email address).  Otherwise, split the email address into the local part which comes before the first <span class="tt">@</span> sign and the domain, which comes after the first <span class="tt">@</span> sign.  (The <span class="tt">@</span> sign is in neither the local nor the domain part.)</p>

`en=<p>Apply the <span class="tt">check;//Blank()</span> function defined in ;&S2 <a href="#sec2">Common definitions</a> to both the local part and the domain part.  If either check fails, then the email address is invalid, so normalize it to an (invalid) empty string.</p>

`en=<p>The local part needs no further normalization.  For the domain part, use the <span class="tt">norm;//Domain()</span> function defined in ;&S2.3 <a href="#sec2p3">Domain definition</a>.</p>

`en=<p>Finally, reassemble the normalized email address by concatenating the normalized local part, the <span class="tt">@</span> sign, and the normalized domain.</p>

`en=<p>The following function is available to perform this normalization:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>normEmail</b>(<br/>
  $str : string | mixed<br/>
) : string
`$
</blockquote>

`en=<p>If something besides a string is passed to it, an empty string will be returned, which is not a valid email address.  The function does <i>not</i> verify that email addresses are valid.</p>

`en=<p>Once an email address has been normalized, it can be validated using the following procedure.</p>

`en=<p>First, check that the entire email address does not exceed 320 characters.</p>

`en=<p>Second, locate the first <span class="tt">@</span> character within the address.  If no such character exists, validation fails.</p>

`en=<p>Third, split the address into a local part and a domain.  The local part includes everything that occurs before the first <span class="tt">@</span> sign while the domain includes everything that occurs after the first <span class="tt">@</span> sign.  The first <span class="tt">@</span> sign is included in neither part.</p>

`en=<p>Fourth, apply <span class="tt">blank;//Check()</span> to the local part and the domain part, failing if either check fails.</p>

`en=<p>Fifth, check that the local part does not exceed 64 characters in length and that it is at least one character in length.</p>

`en=<p>Sixth, check that the local part consists only of lowercase ASCII letters, ASCII digits, and special characters shown in the table below.  Also check that the period is neither the first nor the last character in the local part, and no period character occurs immediately after another period character.</p>

`en=<p>Here are the allowed special characters within the local part of email addresses:</p>

<blockquote id="teschar">
<table>
  <tr>
    <th>Char</th>
    <th>Code</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>!</td>
    <td>0x21</td>
    <td class="desc">Exclamation mark</td>
  </tr>
  <tr>
    <td>#</td>
    <td>0x23</td>
    <td class="desc">Number sign</td>
  </tr>
  <tr>
    <td>$</td>
    <td>0x24</td>
    <td class="desc">Dollar sign</td>
  </tr>
  <tr>
    <td>%</td>
    <td>0x25</td>
    <td class="desc">Percent sign</td>
  </tr>
  <tr>
    <td>&</td>
    <td>0x26</td>
    <td class="desc">Ampersand</td>
  </tr>
  <tr>
    <td>'</td>
    <td>0x27</td>
    <td class="desc">Apostrophe</td>
  </tr>
  <tr>
    <td>*</td>
    <td>0x2A</td>
    <td class="desc">Asterisk</td>
  </tr>
  <tr>
    <td>+</td>
    <td>0x2B</td>
    <td class="desc">Plus sign</td>
  </tr>
  <tr>
    <td>-</td>
    <td>0x2D</td>
    <td class="desc">Hyphen-minus sign</td>
  </tr>
  <tr>
    <td>.</td>
    <td>0x2E</td>
    <td class="desc">Period</td>
  </tr>
  <tr>
    <td>/</td>
    <td>0x2F</td>
    <td class="desc">Forward slash</td>
  </tr>
  <tr>
    <td>=</td>
    <td>0x3D</td>
    <td class="desc">Equals sign</td>
  </tr>
  <tr>
    <td>?</td>
    <td>0x3F</td>
    <td class="desc">Question mark</td>
  </tr>
  <tr>
    <td>^</td>
    <td>0x5E</td>
    <td class="desc">Circumflex</td>
  </tr>
  <tr>
    <td>_</td>
    <td>0x5F</td>
    <td class="desc">Underscore</td>
  </tr>
  <tr>
    <td>`</td>
    <td>0x60</td>
    <td class="desc">Grave accent</td>
  </tr>
  <tr>
    <td>{(</td>
    <td>0x7B</td>
    <td class="desc">Left curly bracket</td>
  </tr>
  <tr>
    <td>|</td>
    <td>0x7C</td>
    <td class="desc">Vertical bar</td>
  </tr>
  <tr>
    <td>{)</td>
    <td>0x7D</td>
    <td class="desc">Right curly bracket</td>
  </tr>
  <tr>
    <td>~</td>
    <td>0x7E</td>
    <td class="desc">Tilde</td>
  </tr>
</table>
</blockquote>

`en=<p>Seventh and finally, use the <span class="tt">check;//Domain()</span> function defined in ;&S2.3 <a href="#sec2p3">Domain definition</a> to verify the domain portion of the email address.</p>

`en=<p>The following function performs the validation checks described above on a normalized email address:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>checkEmail</b>(<br/>
  $str : string | mixed<br/>
) : boolean
`$
</blockquote>

`en=<p>If a non-string parameter is passed, the return value is always <span class="tt">false</span>.  Email addresses should be normalized first with <span class="tt">norm;//Email()</span> before passing them to the validation function, or validation may fail.  The return value is <span class="tt">true</span> if the email address is valid, <span class="tt">false</span> if the email address is not valid.</p>

`en=<h3 id="sec2p8">2.8 Timestamp definition</h3>

`en=<p>A <i>timestamp</i> represents a specific point in time as an integer value.  The only restriction on the value is that it must be greater than zero.  The definition of a timestamp given here matches the ;'(Unix time;') definition used in PHP by the standard <span class="tt">time()</span> function as well as more broadly throughout Unix operating systems.</p>

`en=<p>A timestamp counts the total number of seconds that have passed since midnight GMT at the start of January 1, 1970.  For sake of the timestamp, each minute always has exactly 60 seconds ;-m UTC leap seconds are not accounted for in timestamp values (nor in Unix time).</p>

`en=<p>It is important for security reasons that the time always be read from the server and <i>never</i> from the client.  This prevents clients spoofing the current time.</p>

`en=<p>When timestamps are stored in archive files, however, it is better to represent them in a date and time string that can be understood by the user.  The specific format is defined in <a href="#extRFC3339">[RFC-;//3339]</a>, which is based on the ISO 8601 standard.  Jacques-;//Types adds two additional restrictions:</p>

<ol>
`en=<li>The timezone should be UTC</li>
`en=<li>Only US-ASCII characters should be used</li>
</ol>

`en=<p>(The second restriction is due to the suggestion in some sources that a special Unicode minus character should be used instead of the US-;//ASCII hyphen-;//minus.  Jacques-;//Types only supports the US-;//ASCII hyphen-;//minus.)</p>

`en=<p>The UTC timezone can be rendered as any of the following suffixes:</p>

<ul>
`en=<li><span class="tt">Z</span></li>
`en=<li><span class="tt">+00</span></li>
`en=<li><span class="tt">-00</span></li>
`en=<li><span class="tt">+0000</span></li>
`en=<li><span class="tt">-0000</span></li>
`en=<li><span class="tt">+00:00</span></li>
`en=<li><span class="tt">-00:00</span></li>
</ul>

An example of a timestamp stored in this format is given below:</p>

<blockquote class="cblock">
`#L:
2021-04-13T23:03:01+00:00<br/>
<br/>
yyyy-mm-ddThh:mm:ss[time-zone]
`$
</blockquote>

`en=<p>Only US-ASCII characters should be used in this time format.  When parsing, the string should be trimmed and converted to uppercase.</p>

`en=<p>The following function takes a timestamp integer value and encodes it in the string format described above:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>encodeTime</b>(<br/>
  $ival : integer | mixed<br/>
) : string | false
`$
</blockquote>

`en=<p>The function fails unless the parameter passed is an integer that is greater than zero.  If the function fails, <span class="tt">false</span> is returned;; else, the return value is the formatted time string.</p>

`en=<p>To convert a formatted time string into an integer timestamp, use the following function:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>decodeTime</b>(<br/>
  $sval : string | mixed<br/>
) : integer | false
`$
</blockquote>

`en=<p>The function fails unless the parameter passed is a string in an appropriate time format.  While the encode function only generates strings in the UTC time zone, the decode function accepts strings with any kind of time zone suffix and converts them appropriately.  If the function fails, <span class="tt">false</span> is returned;; else, the return value is the corresponding integer timestamp.</p>

`en=<h3 id="sec2p9">2.9 Atom definition</h3>

`en=<p><i>Atoms</i> are short, meaningful strings that look like PHP variable names.  An atom has the same format as PHP variable names, except that it does not allow for extended (non-;//ASCII) characters.  Specifically, a valid atom:</p>

<ol>
`en=<li>Has at least one character</li>
`en=<li>Starts with an ASCII letter or underscore</li>
`en=<li>Contains only ASCII alphanumeric characters and underscores</li>
`en=<li>Is case-;//sensitive</li>
</ol>

`en=<p>Note that atoms do <i>not</i> begin with a <span class="tt">$</span> prefix.</p>

`en=<p>To normalize an atom, use the following function:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>normAtom</b>(<br/>
  $str : string | mixed<br/>
) : string
`$
</blockquote>

`en=<p>If something other than a string is passed, the effect is the same as passing an empty string.  The return string is <i>not</i> guaranteed to be a valid atom.</p>

`en=<p>The only thing this function does is to trim the given string of leading and trailing whitespace.</p>

`en=<p>To validate a normalized atom, use the following function:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>checkAtom</b>(<br/>
  $str : string | mixed<br/>
) : boolean
`$
</blockquote>

`en=<p>You should normalize the atom first with <span class="tt">norm;//Atom()</span> or the non-;//normalized text may fail validation.</p>

`en=<p>Passing a non-string parameter always causes the function to return <span class="tt">false</span>.  The function returns a boolean value that is <span class="tt">true</span> if the atom is valid in format and <span class="tt">false</span> otherwise.  The format of a valid atom is described earlier in this section.</p>

`en=<h3 id="sec2p10">2.10 Unicode string definition</h3>

`en=<p>A <i>Unicode string</i> is a string value that can contain a broad range of Unicode codepoints.  Unicode strings as defined here have a simple backslash-;//escaping mechanism so that tabs and line breaks can be included while still keeping all information on one line without tabulation formatting.</p>

`en=<p>To create a Unicode string from raw binary data, use the following function:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>makeUniString</b>(<br/>
  $str       : string,<br/>
  $multiline : boolean<br/>
) : string
`$
</blockquote>

`en=<p>An Exception is thrown if the given parameters do not have the expected types.</p>

`en=<p>The first step is to convert backslash characters to a pair of backslash characters.  This allows backslash escaping to be used in subsequent steps, with two backslashes used as the escape for a literal backslash.</p>

`en=<p>The second step is to convert ASCII Horizontal Tab (HT) characters.  If <span class="tt">multiline</span> is <span class="tt">true</span> then each HT is converted to the escape sequence <span class="tt">\t</span> else each HT is converted to an ASCII space character.</p>

`en=<p>The third step is to convert CR+LF, LF, and CR line breaks.  If <span class="tt">multiline</span> is <span class="tt">true</span> then each line break is converted to the escape sequence <span class="tt">\n</span> else each line break is converted to an ASCII space character.</p>

`en=<p>The fourth step is to drop illegal ASCII control codes from the string.  Illegal ASCII control codes are everything remaining in the string with a character code below 0x20, as well as the character code 0x7F.</p>

`en=<p>The fifth step is to convert the given string into UTF-8 if necessary.  The PHP <span class="tt">mb_;//check_;//encoding()</span> function is used to detect whether the string already is valid UTF-8;; if it is, then skip this step.  Otherwise, the string is assumed to be Windows-;//1252 (a superset of ISO-;//8859-;//1).  The Windows-;//1252 encoding is converted to UTF-8 by first dropping invalid extended characters.  The following characters are invalid extended characters in Windows-;//1252:</p>

<blockquote class="cblock">
`#L:
0x81 0x8D 0x8F<br/>
0x90 0x9D
`$
</blockquote>

`en=<p>After invalid Windows-;//1252 extended characters have been dropped, the string will be converted to UTF-8 using the PHP function <span class="tt">mb_;//convert_;//encoding()</span>, with an Exception thrown if this conversion fails (which it shouldn;''t).</p>

`en=<p>The sixth step is, if the string has at least three bytes, to check whether the first three bytes have the values <span class="tt">0xEF</span> <span class="tt">0xBB</span> <span class="tt">0xBF</span>.  If they do, then drop the first three bytes (which are a UTF-8 Byte Order Mark [BOM]) from the string before proceeding.</p>

`en=<p>The seventh step is to go through the Unicode codepoints one by one and drop all of the following codepoint ranges from the string:</p>

<blockquote class="cblock">
`#L:
[0x80, 0x84]<br/>
[0x86, 0x9F]<br/>
[0xD800, 0xDFFF]<br/>
[0xFDD0, 0xFDEF]<br/>
[0xFFFE, 0xFFFF]<br/>
[0x1FFFE, 0x1FFFF]<br/>
[0x2FFFE, 0x2FFFF]<br/>
[0x3FFFE, 0x3FFFF]<br/>
[0x4FFFE, 0x4FFFF]<br/>
[0x5FFFE, 0x5FFFF]<br/>
[0x6FFFE, 0x6FFFF]<br/>
[0x7FFFE, 0x7FFFF]<br/>
[0x8FFFE, 0x8FFFF]<br/>
[0x9FFFE, 0x9FFFF]<br/>
[0xAFFFE, 0xAFFFF]<br/>
[0xBFFFE, 0xBFFFF]<br/>
[0xCFFFE, 0xCFFFF]<br/>
[0xDFFFE, 0xDFFFF]<br/>
[0xEFFFE, 0xEFFFF]<br/>
[0xFFFFE, 0xFFFFF]<br/>
[0x10FFFE, +infinity)
`$
</blockquote>

`en=<p>The eighth and final step is to normalize the Unicode to NFC using the PHP <span class="tt">Normalizer</span> class.</p>

`en=<p>To check whether a given string is a valid Unicode string, use the following function:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>checkUniString</b>(<br/>
  $str : string | mixed<br/>
) : boolean
`$
</blockquote>

`en=<p>This checks the following:</p>

<ol>
`en=<li><span class="tt">str</span> is a string</li>
`en=<li>The string is valid UTF-8.</li>
`en=<li>The string has no ASCII controls ([0x00, 0x1F] and 0x7F).</li>
`en=<li>Only <span class="tt">\\</span> <span class="tt">\t</span> and <span class="tt">\n</span> are used as backslash escapes.</li>
`en=<li>No codepoints from the blocked Unicode codepoint ranges table given above are present.</li>
`en=<li>The string is in Unicode NFC normalization form.</li>
</ol>

`en=<p>If you want to display a Unicode string that has been created with the previous function, first decode the escape codes with the following function:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>decodeUniString</b>(<br/>
  $str       : string,<br/>
  $multiline : boolean<br/>
) : string
`$
</blockquote>

`en=<p>An Exception is thrown if values of the wrong type are passed as parameters.  An Exception is also thrown if the <span class="tt">str</span> parameter doesn;''t check out with <span class="tt">check;//Uni;//String()</span>.</p>

`en=<p>This function replaces the escape sequences <span class="tt">\\</span> <span class="tt">\t</span> and <span class="tt">\n</span> with literal backslash, horizontal tab (HT), and line feed (LF), respectively, if <span class="tt">multiline</span> is <span class="tt">true</span>.  Otherwise, <span class="tt">\\</span> is converted to literal backslash while <span class="tt">\t</span> and <span class="tt">\n</span> are converted to a space character.</p>

`en=<p>If you need to convert the formatting codes to something else, you can use the PHP <span class="tt">str_;//replace()</span> function to replace the Horizontal Tab (HT;; <span class="tt">\t</span>) and the Line Feed (LF;; <span class="tt">\n</span>) with whatever is appropriate.  Do this <i>after</i> passing the string through <span class="tt">decode;//Uni;//String()</span>.</p>

`en=<p>If you are combining this function with the <span class="tt">xml;//Uni;//String()</span> function defined later to format the string for display in (X)HTML, then you should do <span class="tt">xml;//Uni;//String()</span> <i>before</i> you use this function, so that converted formatting codes that use HTML markup won;''t have their markup characters escaped.</p>

`en=<p>It is safe to store Unicode strings created by <span class="tt">make;//Uni;//String()</span> directly in database fields <b>only if</b> you are using prepared statements that allow you to provide the parameter values separately from the code.  If you are including such Unicode strings in SQL code, you must first escape any single-;//quote characters within the string using the following function:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>sqlUniString</b>(<br/>
  $str : string<br/>
) : string
`$
</blockquote>

`en=<p>The parameter given to this function must pass <span class="tt">check;//Uni;//String()</span> or an Exception is thrown.  This function simply replaces all ASCII single-;//quote characters in the string with two ASCII single quotes in a row, which is the standard escaping style.  You should run the string through <span class="tt">make;//Uni;//String()</span> <i>before</i> passing it to this function.  The opening and closing single quotes that wrap the literal value are <b>not</b> added, so you still need to surround the return value with single quotes inside the SQL code.</p>

`en=<p><b>Important:</b> do <b>not</b> use <span class="tt">sql;//Uni;//String()</span> if you are using a prepared statement.  The quotes should <i>not</i> be escaped in this case.</p>

`en=<p>If you want to store Unicode strings inside <a href="#extXML">[XML]</a> (or HTML), you must escape certain special characters as XML entities.  The following function performs this escaping:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>xmlUniString</b>(<br/>
  $str : string,<br/>
  $loc : integer<br/>
) : string
`$
</blockquote>

`en=<p>The <span class="tt">loc</span> parameter must be one of the following constants defined within the <span class="tt">JCQ;//Types</span> class, which indicates where the text will be inserted:</p>

<ul>
`en=<li><span class="tt">JCQTypes::CDATA</span> for regular character data</li>
`en=<li><span class="tt">JCQTypes::SQUOTE</span> for single-quoted attribute value</li>
`en=<li><span class="tt">JCQTypes::DQUOTE</span> for double-quoted attribute value</li>
</ul>

`en=<p>An Exception is thrown if parameters of the wrong type are passed, or if the <span class="tt">str</span> parameter doesn;''t pass <span class="tt">check;//Uni;//String()</span>.</p>

`en=<p>You should pass the string through <span class="tt">make;//Uni;//String()</span> <i>before</i> passing it to this function.  If using this function in conjunction with <span class="tt">decode;//Uni;//String()</span>, use this function first.</p>

`en=<p>The returned string will have the special characters escaped using the table shown below.  The returned string will <i>not</i> include any enclosing double- or single-;//quote marks.</p>

`en=<p>The following table shows the special characters, the XML entities that they are escaped with, and which <span class="tt">loc</span> parameter values the escape is used with:</p>

<blockquote id="xesc">
<table>
  <tr>
    <th>Special</th>
    <th>Escape</th>
    <th>DQUOTE</th>
    <th>SQUOTE</th>
    <th>CDATA</th>
  </tr>
  <tr>
    <td>{[</td>
    <td class="esc">&lt;;</td>
    <td>+</td>
    <td>+</td>
    <td>+</td>
  </tr>
  <tr>
    <td>{]</td>
    <td class="esc">&gt;;</td>
    <td>+</td>
    <td>+</td>
    <td>+</td>
  </tr>
  <tr>
    <td>&</td>
    <td class="esc">&amp;;</td>
    <td>+</td>
    <td>+</td>
    <td>+</td>
  </tr>
  <tr>
    <td>'</td>
    <td class="esc">&apos;;</td>
    <td>;_</td>
    <td>+</td>
    <td>;_</td>
  </tr>
  <tr>
    <td>"</td>
    <td class="esc">&quot;;</td>
    <td>+</td>
    <td>;_</td>
    <td>;_</td>
  </tr>
</table>
</blockquote>

`en=<p>The returned string will have all the appropriate escapes applied, but it will <i>not</i> include the enclosing double- or single-;//quote marks.</p>

`en=<h3 id="sec2p11">2.11 Filename definition</h3>

`en=<p>A <i>filename</i> is a simple textual name format that is designed for use in portable file names.  It is based on the <a href="#extEMCA119">[ECMA-;//119]</a> standard;; specifically, on the ;'(file identifier format;') in ;&S7.5.1 of that standard, using only d-characters, with a required file name, with an optional extension, but no version number.  This is similar to the file name definition in the classic <a href="#extISO9660">[ISO-;//9660]</a> standard, except it allows for longer file names.</p>

`en=<p>The definition given in this section also blocks certain special device names from being used as filenames, which can cause problems on Windows (and DOS) platforms.</p>

`en=<p>Each filename is case-;//insensitive.  To enforce this restriction even on case-;//sensitive file systems, all filenames are required to be in lowercase only.  The normalization procedure will enforce this restriction.</p>

`en=<p>The following restrictions apply to filenames:</p>

<blockquote class="iblock">
`en=<p>(1) Filenames may only use ASCII alphanumeric characters, the underscore, and the dot.</p>

`en=<p>(2) Only lowercase alphabet letters may be used.  Uppercase alphabet letters will be normalized to their lowercase equivalents.</p>

`en=<p>(3) The dot may be used at most once, and it may be neither the first nor the last character.</p>

`en=<p>(4) The total length of the filename may be at most 31 characters.</p>

`en=<p>(5) The filename must be at least one character.</p>

`en=<p>(6) The ;'(filename proper;') may not match any ;'(special device name;') (see below).</p>
</blockquote>

`en=<p>The <i>filename proper</i> is the entire filename if there is no dot;; otherwise, it is the filename up to but excluding the dot.  The filename proper is not allowed to match any of the special device names defined in <a href="#extWinfile">[WIN-;//FILE]</a>.  These special device names (normalized to lowercase) are as follows, where the <span class="tt">#</span> character means any ASCII decimal digit 1-9:</p>

<ul>
<li><span class="tt">aux</span></li>
<li><span class="tt">com#</span></li>
<li><span class="tt">con</span></li>
<li><span class="tt">lpt#</span></li>
<li><span class="tt">nul</span></li>
<li><span class="tt">prn</span></li>
</ul>

`en=<p>To normalize a filename, use the following function:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>normFilename</b>(<br/>
  $str : string | mixed<br/>
) : string
`$
</blockquote>

`en=<p>If something other than a string is passed, the effect is the same as passing an empty string.  The return string is <i>not</i> guaranteed to be a valid filename.</p>

`en=<p>The only thing this function does is to trim the given string of leading and trailing whitespace and to convert all uppercase ASCII letters to lowercase.</p>

`en=<p>To validate a normalized filename, use the following function:</p>

<blockquote class="cblock">
`#L:
JCQTypes::<b>checkFilename</b>(<br/>
  $str : string | mixed<br/>
) : boolean
`$
</blockquote>

`en=<p>You should normalize the filename first with <span class="tt">norm;//Filename()</span> or the non-;//normalized text may fail validation.</p>

`en=<p>Passing a non-string parameter always causes the function to return <span class="tt">false</span>.  The function returns a boolean value that is <span class="tt">true</span> if the filename is valid in format and <span class="tt">false</span> otherwise.  The format of a valid filename is described earlier in this section.</p>

<hr/>

`en=<h2 id="secA">A. External references</h2>

`en=<p id="extBark">[BARK] ;-m Bark project<br/>
Canidtech<br/>
<a href="https://www.purl.org/canidtech/r/bark">https://www.purl.org/canidtech/r/bark</a></p>

`en=<p id="extEMCA119">[ECMA-119] ;-m ;'(Volume and file structure of CDROM for information interchange;')<br/>
ECMA International<br/>
<a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-119/">https://www.ecma-international.org/publications-and-standards/standards/ecma-119/</a></p>

`en=<p id="extISO9660">[ISO-9660] ;-m ;'(Information processing ;-m Volume and file structure of CD-ROM for information interchange;')<br/>
ISO<br/>
<a href="https://www.iso.org/standard/17505.html">https://www.iso.org/standard/17505.html</a></p>

`en=<p id="extRFC3339">[RFC-3339] ;-m ;'(Date and Time on the Internet: Timestamps;')<br/>
The Internet Society<br/>
<a href="https://tools.ietf.org/html/rfc3339">https://tools.ietf.org/html/rfc3339</a></p>

`en=<p id="extRFC3986">[RFC-3986] ;-m ;'(Uniform Resource Identifier (URI): Generic Syntax;')<br/>
The Internet Society<br/>
<a href="https://tools.ietf.org/html/rfc3986">https://tools.ietf.org/html/rfc3986</a></p>

`en=<p id="extRFC3696">[RFC-3696] ;-m ;'(Application Techniques for Checking and Transformation of Names;')<br/>
The Internet Society<br/>
<a href="https://tools.ietf.org/html/rfc3696">https://tools.ietf.org/html/rfc3696</a></p>

`en=<p id="extWinfile">[WIN-FILE] ;-m ;'(Naming Files, Paths, and Namespaces;')<br/>
Microsoft<br/>
<a href="https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file">https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file</a></p>

`en=<p id="extXML">[XML] ;-m Extensible Markup Language (XML) 1.0<br/>
W3C<br/>
<a href="https://www.w3.org/TR/REC-xml/">https://www.w3.org/TR/REC-xml/</a></p>

`en=<h2 id="secB">B. Building the specification</h2>

`en=<p>The HTML source code of this specification is auto-generated by <a href="#extBark">[BARK]</a> from the <a href="jcqtypes.html.bark">jcqtypes.html.bark</a> source file.  Changes should be made to the Bark source file, which should then be recompiled with Bark, instead of directly modifying the HTML code.</p>

`en=<p>The webfonts used to render this specification are included in the <span class="tt">fonts</span> subdirectory.  Please see the <a href="fonts/README.txt">README</a> file in that subdirectory for further information about the webfonts and their licenses.</p>

`en=<h2 id="secC">C. Specification license</h2>

`^{
` The following code was originally auto-generated from
` creativecommons.org, but it has been manually modified to clean up the
` HTML source code so that it validates correctly:
<div>
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />Jacques-Types Specification by Multimedia Data Technology Inc is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br />Permissions beyond the scope of this license may be available at <a href="https://www.canidtech.com/">https://www.canidtech.com/</a>.
</div>
`^}

`#L:
<hr/>
<div id="footline">
Multimedia Data Technology, Inc.<br/>
<a href="https://www.canidtech.com/">www.canidtech.com</a><br/>
<br/>
`en=Written by Noah Johnson<br/>
<span class="tt">noah.johnson@loupmail.com</span><br/>
<br/>
`en=April 2021
</div>
`$

  </body>
</html>
